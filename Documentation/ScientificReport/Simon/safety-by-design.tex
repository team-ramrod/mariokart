\section{Safety - A Method}
Risk, according to ISO 31000\cite{ISO31000}, is the effect of uncertainty on objectives. 
Therefore, in order to minimise risk we need to minimise uncertainty.

In practical terms this means analysing the system from the top down,
creating a hierarchy of risks to ensure that all issues are considered. 
Taking this approach means that even if the engineer does not identify
every possible failure mode (which is very likely), mitigation for the
failure modes not identified is still be achieved in a broader sense. 
When applying a divide and conquer approach as below we only need
to ensure that the for each set of risks is equal to the union of those below it.

\subsection{Pitfalls in Risk Management}
relying on qualitative judgement

Checking after vs integrated into design

\subsection{Preventing Mistakes}
reference Wim

\subsection{Risk Analysis}


Project managementy stuff

 Full description of all possible failure modes

\subsection{Mitigation}
Results of previous section

Global mitigations

Specific mitigations

Un-mitigated risk?

\subsection{Minimising Risk Through Modelling}
What modelling is in this context

SPIN, a short intro with references

The scope of a model - law of diminishing returns - Modelling needs to be a worthwhile investment

Modelling the temporal responses of the system - or not

\subsubsection{The Benefits of Modelling a Distributed System}
Promela model vs state diagrams and other sketched plans - or both. iSpin will
 generate sequence diagrams to help visualise process execution.

\subsection{Modelling Mariokart}
A focus on message passing and states.

Unexpected behaviour (errors and power loss) are explicitly specified instead of 
a fine-grained model in which these may arise naturally.

Explain the never claim. plus the automatically generated claims.


\section{Discussion}
A responsible engineer develops his design before implementing it and it is the author's opinion 
that this is belief is sometimes lacking in software development. Since a promela model skips
this details of an implementation it is simple to write and does not bury the top level design 
with details. If written beforehand or concurrently then it simplifies writing the software proper
as the design is already specified and proven.

Balancing the cost of Modelling with the benefits it can bring. At what level of detail is it no longer worth 
exploring - dependence on project budget and magnitude of risk outcomes. Focus on projects similar to
Mariokart (ie ones I have experience in).

\section{Conclusion}
